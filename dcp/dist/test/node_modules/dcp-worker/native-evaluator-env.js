;/** @file       sa-ww-simulation.js 
 *              A simulated WebWorker evaluator environment.
 *
 *  Takes onreadln, writeln & more from the native & node evaluators 
 *  and implements web worker API functionality.
 *  This environment is designed so that no I/O etc is permitted, beyond
 *  communication with stdin and stdout using a well-defined protocol, exposed
 *  via a WebWorker-like API using postMessage etc.
 *
 *  The native & node evaluators provide the following API on the global object when this
 *  program is evaluated:
 *  - writeln('string')         Write a message to stdout.
 *  - onreadln(function)        Dispatch function, with a single string
 *                              argument, when a message is received on stdin.
 *                              Each string is a single JSON-serialized object.
 *  - die()                     Tell the host environment that it's time to end
 *                              it all.
 *
 *  @author     Wes Garland, wes@sparc.network
 *  @date       March 2018
 *
 *  @note       Unusual function scoping is done to eliminate spurious symbols
 *              from being accessible from the global object, to mitigate
 *              certain classes of security risks.  The global object here is
 *              the top of the scope chain (ie global object) for all code run
 *              by hosts in this environment.
 */

/* globals writeln, onreadln, die */
// @ts-nocheck

/**
 * self is a localscope reference to the global object. All subsequent files run
 * after this one will have localscope access to 'self'. This is done to emulate
 * web workers which already have self defined. 
 */
const self = this;
var debug = false;
delete self.console;

try {
  (function privateScope(writeln, onreadln, die) {
    /* Implement console.log which propagates messages to stdout. */
    var console = {
      log: function workerControl$$log () {
        writeln('LOG:' + Array.prototype.slice.call(arguments).join(' ').replace(/\n/g,"\u2424"))
      }
    }

    self._console = console
    try {
      self.console = console
      console.debug = console.log
      console.error = console.log
      console.warn = console.log
    } catch (e) {}

    var inMsg, outMsg

    var eventListeners = {}
    var onHandlerTypes = ['message', 'error']
    var onHandlers = {}
    var serialize = JSON.stringify
    var deserialize = JSON.parse

    self.postMessage = function workerControl$$Worker$postMessage (message) {
      send({type: 'workerMessage', message });
    }

    self.addEventListener = function workerControl$$Worker$addEventListener (type, listener) {
      if (typeof eventListeners[type] === 'undefined') { eventListeners[type] = [] }
      eventListeners[type].push(listener)
    }

    self.removeEventListener = function workerControl$$Worker$removeEventListener (type, listener) {
      if (typeof eventListeners[type] === 'undefined') { return }

      const i = eventListeners[type].indexOf(listener)
      if (i !== -1) { eventListeners[type].splice(i, 1) }
    }

    for (let i = 0; i < onHandlerTypes.length; i++) {
      let onHandlerType = onHandlerTypes[i]
      Object.defineProperty(self, 'on' + onHandlerType, {
        enumerable: true,
        configurable: false,
        set: function (cb) {
          this.removeEventListener(onHandlerType, onHandlers[onHandlerType])
          this.addEventListener(onHandlerType, cb)
          onHandlers[onHandlerType] = cb
        },
        get: function () {
          return onHandlers[onHandlerType]
        }
      })
    }

    /** Emit an event */
    function emitEvent(eventName, argument) {
      if (eventListeners[eventName]) {
        for (let i = 0; i < eventListeners[eventName].length; i++) {
          eventListeners[eventName][i].call(self, argument)
        }
      }
    }

    /** Send a message to stdout.
     *  This defines the "from evaluator" half of the protocol.
     */
    function send (outMsg) {
      outMsg = serialize(outMsg)
      writeln('MSG:' + outMsg)
    }

    /** Receive a line from stdin.
     *  This defines the "to evaluator" half of the protocol.
     */
    onreadln(function receiveLine(line) {
      try {
        outMsg = { type: 'result', step: 'parseInput::' + deserialize.name, success: false }
        inMsg = deserialize(line)
        outMsg.origin = inMsg.type
        outMsg.step = inMsg.type || 'parseMessage'
        switch (inMsg.type) {
        default:
          throw new Error("Invalid message type '" + (typeof inMsg.type === 'string' ? inMsg.type : JSON.stringify(inMsg.type)) + "'")
        case 'newSerializer':
          outMsg.step = 'changeSerializer'
          let newSerializer = eval(inMsg.payload)
          outMsg.success = true
          send(outMsg) // acknowledge change in old format
          serialize = newSerializer.serialize
          deserialize = newSerializer.deserialize
          outMsg = { type: 'nop', success: true }
          break
        case 'workerMessage':
          emitEvent('message', {data: inMsg.message})
          outMsg.success = true
          break
        case 'die':
          writeln('DIE: ' + Date())
          outMsg.success = true
          die();
          break;
        }
      } catch (e) {
        /* Return exceptions thrown in this engine (presumably the host code) to stdout for reporting. */
        outMsg.success = false
        outMsg.exception = { name: e.name, message: e.message, fileName: e.fileName, lineNumber: e.lineNumber, stack: e.stack }
        outMsg.e = e
      } finally {
        send(outMsg)
      }
    }) /* receiveLine */
  })(writeln, onreadln, die) /* privateScope */

  writeln = onreadln = die = undefined
  delete self.writeln
  delete self.onreadln
  delete self.die

} catch (e) {
  writeln('DIE: ' + e.message);
  die();
}
;/** 
 *  @file       evaluator-lib/script-load-wrapper.js
 * 
 *  This file provides a global function for all proceeding scripts to wrap their
 *  initialization. It will post messages about the success/failure of the script
 *  and handles wrapping of post message when the flag is set.
 * 
 *  @author     Ryan Rossiter, ryan@kingsds.network
 *  @date       September 2020
 */

(() => {
  let currentRing = -1;
  function wrapPostMessage() {
    const currentPostMessage = self.postMessage;
    const ringSource = ++currentRing;
    return self.postMessage = function (value) {
      currentPostMessage({ ringSource, value });
    }
  }

  const ring0PostMessage = wrapPostMessage();

  /**
   * This function is used by evaluator scripts to wrap their evaluation so that
   * errors can be caught and reported, and to discourage pollution of the global
   * scope by enclosing them in a function scope.
   * 
   * @param {object} options
   * @param {string} options.scriptName The name of the script that is being loaded
   * @param {boolean} [options.ringTransition] When true, the global postMessage ring will be incremented before the function is invoked
   * @param {boolean} [options.finalScript] When true, the wrapScriptLoading function will be removed from the global scope afterwards
   * @param {function} fn
   */
  self.wrapScriptLoading = function scriptLoadWrapper$wrapScriptLoading(options, fn) {
    try {
      // capture the current postMessage before transitioning rings
      const fixedPostMessage = self.postMessage;
      if (options.ringTransition) {
        wrapPostMessage();
      }

      fn(fixedPostMessage, wrapPostMessage);

      ring0PostMessage({
        request: 'scriptLoaded',
        script: options.scriptName,
        result: "success",
      });

      if (options.finalScript) {
        delete self.wrapScriptLoading;

        ring0PostMessage({
          request: 'sandboxLoaded',
        })
      }
    } catch (e) {
      ring0PostMessage({
          request: 'scriptLoaded',
          script: options.scriptName,
          result: "failure",
          error: {
              name: e.name,
              message: e.message,
              stack: e.stack.replace(
                  /data:application\/javascript.*?:/g,
                  'eval:'
              ),
          }
      });
    }
  }
})();

self.wrapScriptLoading({ scriptName: 'script-load-wrapper' }, () => {
  // noop
});
;/**
 *  @file       event-loop-virtualization.js
 *              
 *  File that takes control of our regular evaluator event loops.
 *  This gives DCP introspection capability to see how long a job
 *  should take, and how we can pay DCCs accordingly.
 * 
 *  The node, v8, and web worker evaluators have been modified to
 *  provide the following primitive functions onto the global object
 *  when this program is evaluated:
 *  - ontimer             will be invoked by the reactor when there are timers that
 *                        should need servicing based on the information provided to nextTimer().    
 *  - nextTimer()         sets when the next timer will be fired (in ms)
 *  - evalTimer           evaluates using either the actual setImmediate/setTimeout or uses 
 *                        Promise.resolve.then as a fallback
 *  
 *  Once this file has run, the following methods will be
 *  available on the global object for every evaluator:
 *  - setTimeout()        execute callback after minimum timeout time in ms
 *  - clearTimeout()      clear the timeout created by setTimeout
 *  - setInterval()       recurringly execute callback after minimum timeout time in ms
 *  - clearInterval()     clear the interval created by setInterval
 *  - queueMicrotask()    add a microtask to the microtask queue, bypassing 4ms timeout clamping 
 *
 *  @author     Parker Rowe, parker@kingsds.network
 *  @date       August 2020
 * 
 *  @note       Unusual function scoping is done to eliminate spurious symbols
 *              from being accessible from the global object, to mitigate
 *              certain classes of security risks.  The global object here is
 *              the top of the scope chain (ie global object) for all code run
 *              by hosts in this environment.
 */
/* globals self, ontimer, nextTimer, evalTimer */

self.wrapScriptLoading({ scriptName: 'event-loop-virtualization' }, (ring0PostMessage) => {
  
  if (typeof self.evalTimer === 'undefined'){
    self.evalTimer = (func) => Promise.resolve().then(func);
  }



  (function privateScope(ontimer, nextTimer, evalTimer) {
  
    const timers = [];
    timers.serial = 0; /* If this isn't set, it becomes NaN */

    function sortTimers() {
      timers.sort(function (a, b) { return a.when - b.when; });
    }

    /* Fire any timers which are ready to run, being careful not to
     * get into a recurring timer death loop without reactor mediation.
     */
    ontimer(function fireTimerCallbacks() {
      let now = Date.now();

      sortTimers();
      for (let i = 0; i < timers.length; ++i) {
        let timer = timers[i];
        if (timer.when > now) {
          break;
        }
        evalTimer(timer.fn);
        if (timer.recur) {
          timer.when = Date.now() + timer.recur;
        } else {
          timers.splice(i--, 1);
        }
      }
      if (timers.length) {
        sortTimers();
        nextTimer(timers[0].when);
      }
    });

    /** Execute callback after at least timeout ms. 
     * 
     *  @param    callback          {function} Callback function to fire after a minimum callback time
     *  @param    timeout           {int} integer containing the minimum time to fire callback in ms
     *  @param    arg               array of arguments to be applied to the callback function
     *  @returns                    {object} A value which may be used as the timeoutId parameter of clearTimeout()
     */
    self.setTimeout = function eventLoop$$Worker$setTimeout(callback, timeout, arg) {
      let timer, args;
      if (typeof callback === 'string') {
        let code = callback;
        callback = function eventLoop$$Worker$setTimeout$wrapper() {
          let indirectEval = eval;
          return indirectEval(code);
        }
      }

      // if user supplies arguments, apply them to the callback function
      if (arg) {
        args = Array.prototype.slice.call(arguments); // get a plain array from function arguments
        args = args.slice(2);                         // slice the first two elements (callback & timeout), leaving an array of user arguments
        let fn = callback;
        callback = () => fn.apply(fn, args);          // apply the arguments to the callback function
      }

      timers.serial = +timers.serial + 1;
      timer = {
        fn: callback,
        when: Date.now() + (+timeout || 0),
        serial: timers.serial,
        valueOf: function () { return this.serial; }
      }
      timers.push(timer);
      if (timer.when <= timers[0].when) {
        sortTimers();
        nextTimer(timers[0].when);
      }
      return timer;
    }

    /** Remove a timeout from the list of pending timeouts, regardless of its current
     *  status.
     * 
     *  @param    timeoutId         {object} The value, returned from setTimeout(), identifying the timer.
     */
    self.clearTimeout = function eventLoop$$Worker$clearTimeout(timeoutId) {
      if (typeof timeoutId === "object") {
        let i = timers.indexOf(timeoutId);
        if (i != -1) {
          timers.splice(i, 1);

          /* if there is a timer at the top of the timers list, set that to be the nextTimer to fire
           * otherwise, tell the event loop that there are no more timers to fire, and end the loop accordingly.
           * this fixes a bug where you clear a timeout, but the program still waits that time before ending,
           * despite never calling the callback function
           * 
           * for example:
           * const timeout = setTimeout(() => console.log("hi"), 10000);
           * clearTimeout(timeout); 
           * 
           * used to still wait 10 seconds before closing the program, despite never printing hi to the console
           */
          if (timers.length) {
            nextTimer(timers[0].when);
          }
          else {
            nextTimer(0);
          }
        }
      } else if (typeof timeoutId === "number") { /* slow path - object has been reinterpreted in terms of valueOf() */
        for (let i = 0; i < timers.length; i++) {
          if (timers[i].serial === timeoutId) {
            timers.splice(i, 1);

            if (timers.length) {
              nextTimer(timers[0].when);
            }
            else {
              nextTimer(0);
            }

            break;
          }
        }
      }
    }

    /** Execute callback after at least interval ms, regularly, at least interval ms apart.
     * 
     *  @param    callback          {function} Callback function to fire after a minimum callback time
     *  @param    timeout           {int} integer containing the minimum time to fire callback in ms
     *  @param    arg               array of arguments to be applied to the callback function
     *  @returns                    {object} A value which may be used as the intervalId paramter of clearInterval()
     */
    self.setInterval = function eventLoop$$Worker$setInterval(callback, interval, arg) {
      let timer = self.setTimeout(callback, +interval || 0, arg);
      timer.recur = interval;
      return timer;
    }

    /** Remove an interval timer from the list of pending interval timers, regardless of its current
     *  status. (Same as clearTimeout)
     *
     *  @param    intervalId         {object} The value, returned from setInterval(), identifying the timer.
     */
    self.clearInterval = self.clearTimeout;

    /** queues a microtask to be executed at a safe time prior to control returning to the event loop
     * 
     *  @param    callback          {function} Callback function to fire
     */
    self.queueMicrotask = function eventLoop$$Worker$queueMicrotask(callback) {
      Promise.resolve().then(callback);
    }

    function clearAllTimers() {
      timers.length = 0;
      nextTimer(0);
    }

    addEventListener('message', async (event) => {
      try {
        if (event.data.request === 'clearTimers') {
          clearAllTimers();
          ring0PostMessage({
            request: 'clearTimersDone',
          });
        }
      } catch (error) {
        ring0PostMessage({
          request: 'error',
          error: {
            name: error.name,
            message: error.message,
            stack: error.stack,
          },
        });
      }
    });
  })(self.ontimer, self.nextTimer, self.evalTimer);

  ontimer = nextTimer = evalTimer = undefined;
  delete self.ontimer;
  delete self.nextTimer;
  delete self.evalTimer;
});
;/**
 *  @file       dcp/evaluator/environment/webgpu-worker-environment.js
 *  @author     Dominic Cerisano, dcerisano@kingsds.network
 *  @date       May 2020
 */

//web-worker-environment.js must be included before this environment on the command line.

self.wrapScriptLoading({ scriptName: 'webgpu-evaluator' }, (postMessage)=>{  
  if (typeof GPU !== 'undefined'){
    try{
      GPU.$setPlatform("linux");
      {
        let devices = [];
      
        //Timeouts for polyfills
        //Negative numbers to signal clamping override in evaluator engine.
        //nextTickTimeout is for process.nextTick() polyfill
        //immediateTimeout is for setImmediate() polyfill
      
        self.nextTickTimeout  = -0;
        self.immediateTimeout = -0;
      
        function deviceTick()
        {
          for (let ii = 0; ii < self.devices.length; ++ii) {
            /*if (!device.isDestroyed) */
            self.devices[ii].tick();
          };      
        }
      
        self.setTimeout(deviceTick, self.nextTickTimeout);
      
        GPUAdapter.prototype.requestDevice = function() {
          let args = arguments;
        
          return new Promise((resolve, reject) => {
            this._requestDevice(...args).then(device => {
              device._onErrorCallback = function(type, msg) {
                //Polyfill for process.nextTick
                self.setTimeout(() => {
                  switch (type) {
                  case "Error": throw new Error(msg); break;
                  case "Type": throw new TypeError(msg); break;
                  case "Range": throw new RangeError(msg); break;
                  case "Reference": throw new ReferenceError(msg); break;
                  case "Internal": throw new InternalError(msg); break;
                  case "Syntax": throw new SyntaxError(msg); break;
                  default: throw new Error(msg); break;
                  };
                }, self.immediateTimeout);
              };
          
              devices.push(device);
              resolve(device);
            });
          });
        };
      }
      
      
      
      //Return a promise instead of a callback
      
      {
        GPUFence.prototype.onCompletion = function(completionValue) {
          return new Promise(resolve => {
            //Polyfill for setImmediate
            self.setTimeout(() => {
              this._onCompletion(completionValue, resolve);
            }, self.immediateTimeout);
          });
        };
      }
      
      {
        GPUBuffer.prototype.mapReadAsync = function() {
          return new Promise(resolve => {
            //Polyfill for setImmediate
            self.setTimeout(() => {
              this._mapReadAsync(resolve);
            }, self.immediateTimeout);
          });
        };
      }
      
      {
        GPUBuffer.prototype.mapWriteAsync = function() {
          return new Promise(resolve => {
            //Polyfill for setImmediate
            self.setTimeout(() => {
              this._mapWriteAsync(resolve);
            }, self.immediateTimeout);
          });
        };
      }
      
      {
        GPUDevice.prototype.createBufferMappedAsync = function(descriptor) {
          return new Promise(resolve => {
            //Polyfill for setImmediate
            self.setTimeout(() => {
              this._createBufferMappedAsync(descriptor, resolve);
            }, self.immediateTimeout);
          });
        };
      }
      
      
      
      {
        GPUDevice.prototype.createBufferMapped = function(descriptor) {
          return new Promise(resolve => {
            //Polyfill for setImmediate
            self.setTimeout(() => { 
              this._createBufferMapped(descriptor, resolve); 
            }, self.immediateTimeout);
          });
        };
      }

    
    }catch(err){
      console.log("ERROR: ", err);
    }

  };
});
;/**
 *  @file       worker/evaluator-lib/access-lists.js
 *
 *              This file applies access lists and polyfills to the global object.
 *
 *  @author     Sam Cantor, sam@kingsds.network
 *  @date       Sept 2020
 */

self.wrapScriptLoading({ scriptName: 'access-lists', ringTransition: true }, (ring0PostMessage) => {
  const ring1PostMessage = self.postMessage;

  // aggregated from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#Reflection
  var whitelist = new Set([
    '__proto__',
    '_console',
    'addEventListener',
    'applyWhitelist',
    'Array',
    'ArrayBuffer',
    'AsyncFunction',
    'Atomics',
    'Boolean',
    'Blob',
    'bravojs',
    'clearInterval',
    'clearTimeout',
    'console',
    'constructor',
    'dcpConfig',
    'DataView',
    'Date',
    'decodeURI',
    'decodeURIComponent',
    'encodeURI',
    'encodeURIComponent',
    'Error',
    'escape',
    'eval',
    'EvalError',
    'File',
    'FileReader',
    'Float32Array',
    'Float64Array',
    'Function',
    'Headers',
    'Infinity',
    'Int16Array',
    'Int32Array',
    'Int8Array',
    'isFinite',
    'isNaN',
    'JSON',
    'Map',
    'Math',
    'module',
    'NaN',
    'navigator',
    'null',
    'Number',
    'Object',
    'OffscreenCanvas',
    'onerror',
    'onmessage',
    'parseFloat',
    'parseInt',
    'performance',
    'postMessage',
    'Promise',
    'propertyIsEnumerable',
    'Proxy',
    'RangeError',
    'ReferenceError',
    'RegExp',
    'removeEventListener',
    'requestAnimationFrame',
    'require',
    'Response',
    'self',
    'Set',
    'setInterval',
    'setTimeout',
    'sleep',
    'String',
    'Symbol',
    'SyntaxError',
    'TextDecoder',
    'TextEncoder',
    'toLocaleString',
    'toString',
    'TypeError',
    'URIError',
    'URL',
    'Uint16Array',
    'Uint32Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'undefined',
    'unescape',
    'valueOf',
    'WeakMap',
    'WeakSet',
    'WebAssembly',
    'WebGL2RenderingContext',
    'WebGLTexture',
    'WorkerGlobalScope',
    // Our own Webgpu symbols
    'WebGPUWindow',
    'GPU',
    'GPUBufferUsage',
    'GPUShaderStage',
    'GPUMapMode',
    // Our own symbols
    'progress',
    'work',
    'flushLastLog'
  ]);

  // Add polyfills for any non-whitelisted symbols
  var polyfills = {
    location: {
      search: ""
    },
    performance: {
      now: Date.now
    },
    importScripts: function () {
      throw new Error('importScripts is not supported on DCP');
    },
    WorkerGlobalScope: typeof globalThis === 'undefined' ? self : globalThis,
    globalThis: typeof globalThis === 'undefined' ? self : globalThis,
    // For browsers/SA-workers that don't support btoa/atob, modified from https://github.com/MaxArt2501/base64-js/blob/master/base64.js
    btoa: function (string) {
      var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

      string = String(string);
      var bitmap, a, b, c,
        result = "", i = 0,
        rest = string.length % 3;

      for (; i < string.length;) {
        if ((a = string.charCodeAt(i++)) > 255
          || (b = string.charCodeAt(i++)) > 255
          || (c = string.charCodeAt(i++)) > 255)
          throw new TypeError("Failed to execute 'btoa': The string to be encoded contains characters outside of the Latin1 range.");

        bitmap = (a << 16) | (b << 8) | c;
        result += b64.charAt(bitmap >> 18 & 63) + b64.charAt(bitmap >> 12 & 63)
          + b64.charAt(bitmap >> 6 & 63) + b64.charAt(bitmap & 63);
      }

      // If there's need of padding, replace the last 'A's with equal signs
      return rest ? result.slice(0, rest - 3) + "===".substring(rest) : result;
    },
    atob: function (string) {
      var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      string = String(string).replace(/[\t\n\f\r ]+/g, "");

      // Adding the padding if missing, for semplicity
      string += "==".slice(2 - (string.length & 3));
      var bitmap, result = "", r1, r2, i = 0;
      for (; i < string.length;) {
        bitmap = b64.indexOf(string.charAt(i++)) << 18 | b64.indexOf(string.charAt(i++)) << 12
          | (r1 = b64.indexOf(string.charAt(i++))) << 6 | (r2 = b64.indexOf(string.charAt(i++)));

        result += r1 === 64 ? String.fromCharCode(bitmap >> 16 & 255)
          : r2 === 64 ? String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255)
            : String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255, bitmap & 255);
      }
      return result;
    }
  };

  // Polyfill for TextEncoder/Decoder
  if (typeof TextEncoder === "undefined") {
    self.TextEncoder = function TextEncoder() { };
    TextEncoder.prototype.encode = function encode(str) {
      "use strict";
      var Len = str.length, resPos = -1;
      // The Uint8Array's length must be at least 3x the length of the string because an invalid UTF-16
      //  takes up the equivelent space of 3 UTF-8 characters to encode it properly. However, Array's
      //  have an auto expanding length and 1.5x should be just the right balance for most uses.
      var resArr = typeof Uint8Array === "undefined" ? new Array(Len * 1.5) : new Uint8Array(Len * 3);
      for (var point = 0, nextcode = 0, i = 0; i !== Len;) {
        point = str.charCodeAt(i), i += 1;
        if (point >= 0xD800 && point <= 0xDBFF) {
          if (i === Len) {
            resArr[resPos += 1] = 0xef/*0b11101111*/; resArr[resPos += 1] = 0xbf/*0b10111111*/;
            resArr[resPos += 1] = 0xbd/*0b10111101*/; break;
          }
          nextcode = str.charCodeAt(i);
          if (nextcode >= 0xDC00 && nextcode <= 0xDFFF) {
            point = (point - 0xD800) * 0x400 + nextcode - 0xDC00 + 0x10000;
            i += 1;
            if (point > 0xffff) {
              resArr[resPos += 1] = (0x1e/*0b11110*/ << 3) | (point >>> 18);
              resArr[resPos += 1] = (0x2/*0b10*/ << 6) | ((point >>> 12) & 0x3f/*0b00111111*/);
              resArr[resPos += 1] = (0x2/*0b10*/ << 6) | ((point >>> 6) & 0x3f/*0b00111111*/);
              resArr[resPos += 1] = (0x2/*0b10*/ << 6) | (point & 0x3f/*0b00111111*/);
              continue;
            }
          } else {
            resArr[resPos += 1] = 0xef/*0b11101111*/; resArr[resPos += 1] = 0xbf/*0b10111111*/;
            resArr[resPos += 1] = 0xbd/*0b10111101*/; continue;
          }
        }
        if (point <= 0x007f) {
          resArr[resPos += 1] = (0x0/*0b0*/ << 7) | point;
        } else if (point <= 0x07ff) {
          resArr[resPos += 1] = (0x6/*0b110*/ << 5) | (point >>> 6);
          resArr[resPos += 1] = (0x2/*0b10*/ << 6) | (point & 0x3f/*0b00111111*/);
        } else {
          resArr[resPos += 1] = (0xe/*0b1110*/ << 4) | (point >>> 12);
          resArr[resPos += 1] = (0x2/*0b10*/ << 6) | ((point >>> 6) & 0x3f/*0b00111111*/);
          resArr[resPos += 1] = (0x2/*0b10*/ << 6) | (point & 0x3f/*0b00111111*/);
        }
      }
      if (typeof Uint8Array !== "undefined") return resArr.subarray(0, resPos + 1);
      // else // IE 6-9
      resArr.length = resPos + 1; // trim off extra weight
      return resArr;
    };
    TextEncoder.prototype.toString = function () { return "[object TextEncoder]"; };
    try { // Object.defineProperty only works on DOM prototypes in IE8
      Object.defineProperty(TextEncoder.prototype, "encoding", {
        get: function () {
          if (TextEncoder.prototype.isPrototypeOf(this)) return "utf-8";
          else throw TypeError("Illegal invocation");
        }
      });
    } catch (e) { /*IE6-8 fallback*/ TextEncoder.prototype.encoding = "utf-8"; }
    if (typeof Symbol !== "undefined") TextEncoder.prototype[Symbol.toStringTag] = "TextEncoder";
  }
  if (typeof TextDecoder === "undefined") {
    self.TextDecoder = function TextDecoder() { };
    TextDecoder.prototype.decode = function (inputArrayOrBuffer) {
      var NativeUint8Array = self.Uint8Array;
      var patchedU8Array = NativeUint8Array || Array;
      var nativeArrayBuffer = NativeUint8Array ? ArrayBuffer : patchedU8Array;
      var tmpBufferU16 = new (NativeUint8Array ? Uint16Array : patchedU8Array)(32);
      var arrayBuffer_isView = nativeArrayBuffer.isView || function (x) { return x && "length" in x; };
      // Check type of input
      var inputAs8 = inputArrayOrBuffer, asObjectString;
      if (!arrayBuffer_isView(inputAs8)) {
        asObjectString = Object_prototype_toString.call(inputAs8);
        if (asObjectString !== arrayBufferString && asObjectString !== sharedArrayBufferString && asObjectString !== undefinedObjectString)
          throw TypeError("Failed to execute 'decode' on 'TextDecoder': The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
        inputAs8 = NativeUint8Array ? new patchedU8Array(inputAs8) : inputAs8 || [];
      }

      var resultingString = "", tmpStr = "", index = 0, len = inputAs8.length | 0, lenMinus32 = len - 32 | 0, nextEnd = 0, nextStop = 0, cp0 = 0, codePoint = 0, minBits = 0, cp1 = 0, pos = 0, tmp = -1;
      // Note that tmp represents the 2nd half of a surrogate pair incase a surrogate gets divided between blocks
      for (; index < len;) {
        nextEnd = index <= lenMinus32 ? 32 : len - index | 0;
        for (; pos < nextEnd; index = index + 1 | 0, pos = pos + 1 | 0) {
          cp0 = inputAs8[index] & 0xff;
          switch (cp0 >> 4) {
            case 15:
              cp1 = inputAs8[index = index + 1 | 0] & 0xff;
              if ((cp1 >> 6) !== 0b10 || 0b11110111 < cp0) {
                index = index - 1 | 0;
                break;
              }
              codePoint = ((cp0 & 0b111) << 6) | (cp1 & 0b00111111);
              minBits = 5; // 20 ensures it never passes -> all invalid replacements
              cp0 = 0x100; //  keep track of th bit size
            case 14:
              cp1 = inputAs8[index = index + 1 | 0] & 0xff;
              codePoint <<= 6;
              codePoint |= ((cp0 & 0b1111) << 6) | (cp1 & 0b00111111);
              minBits = (cp1 >> 6) === 0b10 ? minBits + 4 | 0 : 24; // 24 ensures it never passes -> all invalid replacements
              cp0 = (cp0 + 0x100) & 0x300; // keep track of th bit size
            case 13:
            case 12:
              cp1 = inputAs8[index = index + 1 | 0] & 0xff;
              codePoint <<= 6;
              codePoint |= ((cp0 & 0b11111) << 6) | cp1 & 0b00111111;
              minBits = minBits + 7 | 0;

              // Now, process the code point
              if (index < len && (cp1 >> 6) === 0b10 && (codePoint >> minBits) && codePoint < 0x110000) {
                cp0 = codePoint;
                codePoint = codePoint - 0x10000 | 0;
                if (0 <= codePoint/*0xffff < codePoint*/) { // BMP code point
                  //nextEnd = nextEnd - 1|0;

                  tmp = (codePoint >> 10) + 0xD800 | 0;   // highSurrogate
                  cp0 = (codePoint & 0x3ff) + 0xDC00 | 0; // lowSurrogate (will be inserted later in the switch-statement)

                  if (pos < 31) { // notice 31 instead of 32
                    tmpBufferU16[pos] = tmp;
                    pos = pos + 1 | 0;
                    tmp = -1;
                  } else {// else, we are at the end of the inputAs8 and let tmp0 be filled in later on
                    // NOTE that cp1 is being used as a temporary variable for the swapping of tmp with cp0
                    cp1 = tmp;
                    tmp = cp0;
                    cp0 = cp1;
                  }
                } else nextEnd = nextEnd + 1 | 0; // because we are advancing i without advancing pos
              } else {
                // invalid code point means replacing the whole thing with null replacement characters
                cp0 >>= 8;
                index = index - cp0 - 1 | 0; // reset index  back to what it was before
                cp0 = 0xfffd;
              }


              // Finally, reset the variables for the next go-around
              minBits = 0;
              codePoint = 0;
              nextEnd = index <= lenMinus32 ? 32 : len - index | 0;
            default:
              tmpBufferU16[pos] = cp0; // fill with invalid replacement character
              continue;
            case 11:
            case 10:
            case 9:
            case 8:
          }
          tmpBufferU16[pos] = 0xfffd; // fill with invalid replacement character
        }
        tmpStr += String.fromCharCode(
          tmpBufferU16[0], tmpBufferU16[1], tmpBufferU16[2], tmpBufferU16[3], tmpBufferU16[4], tmpBufferU16[5], tmpBufferU16[6], tmpBufferU16[7],
          tmpBufferU16[8], tmpBufferU16[9], tmpBufferU16[10], tmpBufferU16[11], tmpBufferU16[12], tmpBufferU16[13], tmpBufferU16[14], tmpBufferU16[15],
          tmpBufferU16[16], tmpBufferU16[17], tmpBufferU16[18], tmpBufferU16[19], tmpBufferU16[20], tmpBufferU16[21], tmpBufferU16[22], tmpBufferU16[23],
          tmpBufferU16[24], tmpBufferU16[25], tmpBufferU16[26], tmpBufferU16[27], tmpBufferU16[28], tmpBufferU16[29], tmpBufferU16[30], tmpBufferU16[31]
        );
        if (pos < 32) tmpStr = tmpStr.slice(0, pos - 32 | 0);//-(32-pos));
        if (index < len) {
          //String.fromCharCode.apply(0, tmpBufferU16 : NativeUint8Array ?  tmpBufferU16.subarray(0,pos) : tmpBufferU16.slice(0,pos));
          tmpBufferU16[0] = tmp;
          pos = (~tmp) >>> 31;//tmp !== -1 ? 1 : 0;
          tmp = -1;

          if (tmpStr.length < resultingString.length) continue;
        } else if (tmp !== -1) {
          tmpStr += String.fromCharCode(tmp);
        }

        resultingString += tmpStr;
        tmpStr = "";
      }

      return resultingString;
    };
  }


  // Set values to true to disallow access to symbols
  var blacklist = {
    OffscreenCanvas: false,
  };

  const blacklistRequirements = {
    OffscreenCanvas: "environment.offscreenCanvas"
  };

  /**
   * Applies a whitelist and a blacklist of properties to an object. After this function, if someone tries
   * to access non-whitelisted or blacklisted properties, a warning is logged and it will return undefined.
   *
   * @param {object} obj - The object, which will have the whitelist applied to its properties.
   * @param {Set} whitelist - A set of properties to allow people to access.
   * @param {Set} blacklist - An object of property names mapping to booleans to indicate whether access is allowed or not.
   * @param {Set} blacklistRequirements - An object of property names mapping requirement path strings, used to print useful warnings.
   * @param {Set} polyfills - An object of property names that have been polyfilled.
   */
  function applyAccessLists(obj, whitelist, blacklist = {}, blacklistRequirements = {}, polyfills = {}) {
    if (!obj) { return; }
    Object.getOwnPropertyNames(obj).forEach(function (prop) {
      if (Object.getOwnPropertyDescriptor(obj, prop).configurable) {
        if (!whitelist.has(prop)) {
          let isSet = false;
          let propValue;
          Object.defineProperty(obj, prop, {
            get: function () {
              if (isSet) {
                return propValue;
              } else {
                if (prop in polyfills) {
                  return polyfills[prop];
                }
                return undefined;
              }
            },
            set: function (value) {
              propValue = value;
              isSet = true;
            },
            configurable: false
          });
        } else if (prop in blacklist) {
          let isSet = false;
          let blacklisted = blacklist[prop];
          let requirement = blacklistRequirements[prop];
          let propValue = obj[prop];
          Object.defineProperty(obj, prop, {
            get: function () {
              if (blacklisted && !isSet) {
                return undefined;
              } else {
                return propValue;
              }
            },
            set: function (value) {
              propValue = value;
              isSet = true;
            },
            configurable: false
          });
        }
      }

    });
  }

  /**
   * Applies a list of polyfills to symbols not present in the global object
   * 
   * @param {Object} obj - The global object to add properties on
   * @param {Set} polyfills - An object of property names to create/polyfill 
   */
  function applyPolyfills(obj, polyfills = {}) {
    // Apply symbols from polyfill object
    for (prop in polyfills) {
      let found = false;
      for (let o = obj; o.__proto__ && (o.__proto__ !== Object); o = o.__proto__) {
        if (o.hasOwnProperty(prop)) {
          found = true;
          break;
        }
      }
      if (found) { continue; }
      let propValue = polyfills[prop];
      Object.defineProperty(obj, prop, {
        get: function () {
          return propValue;

        },
        set: function (value) {
          propValue = value;
        },
        configurable: false
      });
    }
  }

  /**
   * Applies the whitelist and blacklist to all global scopes.
   * This must be called after the requirements are assigned to the sandbox
   * so that the blacklist is accessible to modify w/o adding it to the whitelist.
   */
  function applyAllAccessLists() {
    // We need to apply the access lists to global, global.__proto__, and global.__proto__.__proto__,
    // because there's networking-accessing functions inside global.__proto__.__proto__, like fetch.
    //
    // If we're in a robust environment (node, browser, WebWorker, basically anything but v8),
    // then we have to climb the prototype chain and apply the whitelist there, but we have to stop
    // before we whitelist Object's properties

    var global = typeof globalThis === 'undefined' ? self : globalThis;
    // Save them in scope because they'll get hidden by the whitelist
    let _whitelist = whitelist;
    let _blacklist = blacklist;
    let _polyfills = polyfills;

    // Ternary expression to avoid a ReferenceError on navigator
    let _navigator = typeof navigator !== 'undefined' ? navigator : undefined;
    let _GPU       = ((typeof navigator !== 'undefined') && (typeof navigator.gpu !== 'undefined')) ? navigator.gpu : 
      (typeof GPU !== 'undefined'? GPU : undefined);
    let _blacklistRequirements = blacklistRequirements;
    let _applyAccessLists = applyAccessLists;
    let _applyPolyfills = applyPolyfills;
    for (let g = global; g.__proto__ && (g.__proto__ !== Object); g = g.__proto__) {
      _applyAccessLists(g, _whitelist, _blacklist, _blacklistRequirements, _polyfills);
    } 
    if (typeof _navigator === 'undefined') {
      _navigator = navigator = {
        userAgent: 'not a browser',
        gpu: _GPU, 
      };
    } else {
      // We also want to whitelist certain parts of navigator, but not others.
      
      navWhitelist = new Set(['userAgent','gpu']);
      let navPolyfill = {
        userAgent: typeof navigator.userAgent !== 'undefined'? navigator.userAgent : 'not a browser',
        gpu: _GPU 
      };
      _applyAccessLists(navigator.__proto__, navWhitelist, {}, {}, navPolyfill);
      _applyPolyfills(navigator.__proto__, navPolyfill);
    }

    // Define properties for symbols that are not present in the global object
    _applyPolyfills(global, _polyfills);
  }

  /* --- /Sam's section --- */

  /* Polyfill section of workerBootstrap */

  // At time of writing, Chrome defines requestAnimationFrame inside web workers, but
  // Firefox doesn't.
  if (typeof requestAnimationFrame == 'undefined') {
    var global = typeof globalThis === 'undefined' ? self : globalThis;
    global.requestAnimationFrame = callback => setTimeout(callback, 0);
  }

  if (typeof OffscreenCanvas !== 'undefined') {

    // This deals with Firefox bug 1529995, which causes the tab to crash if fenceSync is called.
    if (navigator.userAgent.indexOf('Firefox') >= 0) {
      new OffscreenCanvas(640, 480).getContext('webgl2').__proto__.fenceSync = null;
      // Note: We can't just do the following, since WebGL2RenderingContext isn't defined
      // in Firefox until the first webgl2 context is created.
      // WebGL2RenderingContext.prototype.fenceSync = undefined
    }

    // Make it so that if getContext throws on a given type of context, return null
    // instead of throwing an exception. This replicates Chrome's behaviour.
    OffscreenCanvas.prototype.oldGetContext = OffscreenCanvas.prototype.getContext;
    OffscreenCanvas.prototype.getContext = function getContextPolyfill(type) {
      try {
        return this.oldGetContext(type);
      } catch (e) {
        return null;
      }
    };
  }

  addEventListener('message', async (event) => {
    try {
      if (event.data.request === 'applyRequirements') {
        // This event is fired when the worker is initialized with job requirements,
        // apply restrictions to the environment based on the requirements.
        // Assume the scheduler gave us a nicely-shaped req object.
        const requirements = event.data.requirements;
        blacklist.OffscreenCanvas = !requirements.environment.offscreenCanvas;
        applyAllAccessLists();

        ring1PostMessage({ request: 'applyRequirementsDone' });
      }
    } catch (error) {
      ring1PostMessage({
        request: 'error',
        error: {
          name: error.name,
          message: error.message,
          stack: error.stack,
        }
      });
    }
  });
});
;/**
 *  @file       worker/evaluator-lib/bravojs-init.js
 *              Copyright (c) 2018, Kings Distributed Systems, Ltd.  All Rights Reserved.
 *
 *              This file sets up the environment for bravojs to load properly.
 *
 *  @author     Ryan Rossiter, ryan@kingsds.network
 *  @date       Sept 2020
 */

self.wrapScriptLoading({ scriptName: 'bravojs-init' }, () => {
  self.bravojs = {
    url: '/bravojs/bravo.js',
    mainModuleDir: '.'
  }
});
;/**
 *  This file implements BravoJS, a CommonJS Modules/2.0 environment.
 *
 *  Copyright (c) 2010-2018, PageMail, Inc.
 *  Wes Garland, wes@page.ca
 *  MIT License
 */
var bravojs;                    /**< Namespace object for this implementation */

if (typeof bravojs === "undefined")
  bravojs = {};

try {

if (!bravojs.hasOwnProperty("errorReporter"))
{
  bravojs.errorReporter = function bravojs_defaultErrorReporter(e)
  {
    if (typeof alert === "function")
      alert(" * BravoJS: " + e.name + " - " + e.message + " at " + e.fileName + "@" + e.lineNumber + "\n\n" + e.stack);
    else if (console && console.error)
      console.error(" * BravoJS: " + e.name + " - " + e.message + " at " + e.fileName + "@" + e.lineNumber + "\n\n" + e.stack);
    throw e;
  }
}

if (typeof window === "undefined")
  bravojs.global = self;
else
  bravojs.global = window;

/** Reset the environment so that a new main module can be loaded */
bravojs.reset = function bravojs_reset(mainModuleDir, paths)
{
  bravojs.requireMemo                   = {};   /**< Module exports, indexed by canonical name */
  bravojs.pendingModuleDeclarations     = {};   /**< Module.declare arguments, indexed by canonical name */
  bravojs.paths                         = paths || [];  /**< Backing array for require.paths */
  bravojs.mainModuleDir                 = mainModuleDir
                                          || bravojs.dirname(bravojs.URL_toId(window.location.href + ".js", true)); /**< Current directory for relative paths from main module */
  delete bravojs.Module.prototype.main;
  delete bravojs.scriptTagMemo;
  delete bravojs.scriptTagMemoIE;

  /* Extra-module environment */
  bravojs.global.require = bravojs.requireFactory(bravojs.mainModuleDir);
  bravojs.global.module  = new bravojs.Module('', []);

  /* Module.declare function which handles main modules inline SCRIPT tags.
   * This function gets deleted as soon as it runs, allowing the module.declare
   * from the prototype take over. Modules created from this function have
   * the empty string as module.id.
   */
  bravojs.global.module.declare = function bravojs_main_module_declare(dependencies, moduleFactory)
  {
    if (typeof dependencies === "function")
    {
      moduleFactory = dependencies;
      dependencies = [];
    }

    bravojs.initializeMainModule(dependencies, moduleFactory, '');
  }
}

/** Print to text to stdout */
bravojs.print = function bravojs_print()
{
  var output="";
  var i;
  var stdout;

  for (i=0; i < arguments.length; i++)
    output += arguments[i] + (i===arguments.length - 1 ? "" : " ");
  output.replace(/\t/, "        ");

  if (typeof document !== "undefined" && (stdout = document.getElementById('stdout')))
  {
    output += "\n";

    if (typeof stdout.value !== "undefined")
    {
      stdout.value += output;
      if (stdout.focus)
        stdout.focus();

      if (stdout.tagName === "TEXTAREA")
        stdout.scrollTop = stdout.scrollHeight;
    }
    else
    {
      if (typeof stdout.innerText !== "undefined")
      {
        stdout.innerText = stdout.innerText.slice(0,-1) + output + " ";         /* IE normalizes trailing newlines away */
      }
      else
        stdout.textContent += output;
    }
  }
  else if (typeof console === "object" && console.print)
  {
    console.print(output);
  }
  else if (typeof console === "object" && console.log)
  {
    console.log(output);
  }
  else
    alert(" * BravoJS stdout: " + output);
}

bravojs.warn = function bravojs_warn()
{
  if (typeof console === "object" && console.warn)
    console.warn.apply(console, arguments);
  else
  {
    arguments[0] = "BravoJS Warning: " + arguments[0];
    bravojs.print.apply(this, arguments);
  }
}

/** Canonicalize path, compacting slashes and dots per basic UNIX rules.
 *  Treats paths with trailing slashes as though they end with INDEX instead.
 *  Not rigorous.
 */
bravojs.realpath = function bravojs_realpath(path)
{
  if (typeof path !== "string")
    path = path.toString();

  var oldPath = path.split('/');
  var newPath = [];
  var i;

  if (oldPath[0] === "")
    newPath[0] = "";
  if (oldPath[oldPath.length - 1] === "")
    oldPath[oldPath.length - 1] = ".";

  for (i = 0; i < oldPath.length; i++)
  {
    if (oldPath[i] == '.' || !oldPath[i].length)
      continue;
    if (oldPath[i] == '..')
    {
      if (!newPath.length)
      {
        bravojs.e = new Error("Invalid module path: " + path);
        throw bravojs.e;
      }
      newPath.pop();
      continue;
    }
    newPath.push(oldPath[i]);
  }

  return newPath.join('/');
}

/** Extract the non-directory portion of a path */
bravojs.basename = function bravojs_basename(path)
{
  if (typeof path !== "string")
    path = path.toString();

  var s = path.split('/').slice(-1).join('/');
  if (!s)
    return path;
  return s;
}

/** Extract the directory portion of a path */
bravojs.dirname = function bravojs_dirname(path)
{
  if (typeof path !== "string")
    path = path.toString();

  if (path.charAt(path.length - 1) === '/')
    return path.slice(0,-1);

  var s = path.split('/').slice(0,-1).join('/');
  if (!s)
    return ".";

  return s;
}

/** Find a global module within the requireMemo or pendingModuleDeclarations
 *  @param   moduleIdentifer   A module identifier
 *  @returns the module id (if global and found on path), otherwise null
 */
bravojs.findModule = function bravojs_findModule(moduleIdentifier)
{
  var dir, i;

  if (moduleIdentifier.charAt(0) === '.')
    return null

  for (i=0; i < bravojs.paths.length; i++)
  {
    if ((bravojs.requireMemo.hasOwnProperty(bravojs.paths[i] + '/' + moduleIdentifier)) ||
        (bravojs.pendingModuleDeclarations.hasOwnProperty(bravojs.paths[i] + '/' + moduleIdentifier)))
      return bravojs.paths[i] + '/' + moduleIdentifier;
  }

  return null
}

/** Turn a module identifier and module directory into a canonical
 *  module.id. Global module identifiers are resolved against
 *  require.paths and discovered by looking at the module memos.
 */
bravojs.makeModuleId = function bravojs_makeModuleId(relativeModuleDir, moduleIdentifier)
{
  var id;

  if (moduleIdentifier === '')  /* Special case for main module */
    return '';

  if (typeof moduleIdentifier !== "string")
  {
    bravojs.e = new Error("Invalid module identifier: " + (typeof moduleIdentifier === "object" ? JSON.stringify(moduleIdentifier) : moduleIdentifier));
    throw bravojs.e;
  }

  if (moduleIdentifier.charAt(0) === '/')
  {
    /* Absolute path. Not required by CommonJS but it makes dependency list optimization easier */
    id = moduleIdentifier;
  }
  else
  if ((moduleIdentifier.indexOf("./") == 0) || (moduleIdentifier.indexOf("../") == 0))
  {
    /* Relative module path -- relative to relativeModuleDir */
    id = relativeModuleDir + "/" + moduleIdentifier;
  }
  else
  {
    id = bravojs.findModule(moduleIdentifier)
    if (id === null && typeof bravojs.globalResolveHook === "function")
      id = bravojs.globalResolveHook(moduleIdentifier)
    if (id === null)
      id = bravojs.mainModuleDir + '/' + moduleIdentifier;
  }

  return bravojs.realpath(id);
}

/** Turn a script URL into a canonical module.id */
bravojs.URL_toId = function bravojs_URL_toId(moduleURL, relaxValidation)
{
  var i, s;

  /* Treat the whole web as our module repository, ignoring protocol.
   * 'http://www.page.ca/a/b/module.js' and 'https://www.page.ca/a/b/module.js'
   * both have id '//www.page.ca/a/b/module'.
   */
  moduleURL = moduleURL.replace(/^https?:\/\//i, "//");
  if (!moduleURL.match(/^\/\//))
  {
    if (moduleURL.match(/^file:\/\//i) && window.location.protocol === "file:")  /* only allow file:// modules when using file:// web page */
      id = moduleURL = '@' + bravojs.realpath(moduleURL.slice(5));
    else
    {
      bravojs.e = new Error("Invalid module URL: " + moduleURL);
      throw bravojs.e;
    }
  }
  else
    id = bravojs.realpath(moduleURL.slice(i + 2));

  if ((i = id.indexOf('?')) != -1)
    id = id.slice(0, i);
  if ((i = id.indexOf('#')) != -1)
    id = id.slice(0, i);

  s = id.slice(-3);
  if (!relaxValidation && (s !== ".js"))
  {
    bravojs.e = new Error("Invalid module URL: " + moduleURL);
    throw bravojs.e;
  }
  if (s === ".js")
    id = id.slice(0,-3);

  return id;
}

/** Normalize a dependency array so that only unique and previously unprovided
 *  dependencies appear in the output list. The output list also canonicalizes
 *  the module names relative to the current require, or the rel parameter.
 *  Labeled dependencies are unboxed.
 *
 *  @param      dependencies            A dependency array
 *  @param      rel                     The canonical module id we are resolving
 *                                      dependencies against; if undefined, we
 *                                      use the current require.id method.
 */
bravojs.normalizeDependencyArray = function bravojs_normalizeDependencyArray(dependencies, rel)
{
  var normalizedDependencies = [];
  var i, label;

  function addNormal(moduleIdentifier)
  {
    var id;

    if (rel)
      id = bravojs.makeModuleId(bravojs.dirname(rel), moduleIdentifier);
    else
      id = require.id(moduleIdentifier);

    if (bravojs.requireMemo[id] || bravojs.pendingModuleDeclarations[id])
      return;

    normalizedDependencies.push(id);
  }

  for (i=0; i < dependencies.length; i++)
  {
    switch(typeof dependencies[i])
    {
      case "object":
        for (label in dependencies[i])
        {
          if (dependencies[i].hasOwnProperty(label))
            addNormal(dependencies[i][label]);
        }
        break;

      case "string":
        addNormal(dependencies[i]);
        break;

      default:
        bravojs.e = new Error("Invalid dependency array value at position " + (i+1));
        throw bravojs.e;
    }
  }

  return normalizedDependencies;
}

/** Provide a module to the environment
 *  @param      dependencies            A dependency array
 *  @param      moduleFactoryFunction   The function which will eventually be invoked
 *                                      to decorate the module's exports. If not specified,
 *                                      we assume the factory has already been memoized in
 *                                      the bravojs.pendingModuleDeclarations object.
 *  @param      id                      The module.id of the module we're providing
 *  @param      callback                Optional function to run after the module has been
 *                                      provided to the environment
 */
bravojs.provideModule = function bravojs_provideModule(dependencies, moduleFactory,
                                                       id, callback)
{
  /* Memoize the the factory, satistfy the dependencies, and invoke the callback */
  if (moduleFactory)
    require.memoize(id, dependencies, moduleFactory);

  if (dependencies && dependencies.length > 0)
    module.provide(bravojs.normalizeDependencyArray(dependencies, id), callback);
  else
  {
    if (callback)
      callback();
  }
}

/** Initialize a module. This makes the exports object available to require(),
 *  runs the module factory function, and removes the factory function from
 *  the pendingModuleDeclarations object.
 */
bravojs.initializeModule = function bravojs_initializeModule(id)
{
  var moduleDir     = id ? bravojs.dirname(id) : bravojs.mainModuleDir;
  var moduleFactory = bravojs.pendingModuleDeclarations[id].moduleFactory;
  var dependencies  = bravojs.pendingModuleDeclarations[id].dependencies;
  var require, exports, module;

  delete bravojs.pendingModuleDeclarations[id];

  require = bravojs.requireFactory(moduleDir, dependencies);
  module  = new bravojs.Module(id, dependencies);

  if (bravojs.securableModules === true)
    exports = bravojs.requireMemo[id] = {};
  else
  {
    /* Add node-style replaceable module.exports, unless we need to
     * maintain compatibility with the Securable Modules specification
     * (CommonJS/1.0 precursor).
     */
    function replaceExports(newExports)
    {
      exports = bravojs.requireMemo[id] = newExports;
    }

    Object.defineProperty(module, "exports",
                          {
                            configurable:       true,
                            enumerable:         true,
                            set:                replaceExports
                          });

    module.exports = {};
  }

  moduleFactory(require, exports, module);
}

/** Search the module memo and return the correct module's exports, or throw.
 *  Searching the module memo will initialize a matching pending module factory.
 */
bravojs.requireModule = function bravojs_requireModule(parentModuleDir, moduleIdentifier)
{
  var id = bravojs.makeModuleId(parentModuleDir, moduleIdentifier);
  var e, i, a;

  if (!bravojs.requireMemo[id] && bravojs.pendingModuleDeclarations[id])
    bravojs.initializeModule(id);

  if (id === null || !bravojs.requireMemo[id])
    throw bravojs.e = new Error("Module '" + moduleIdentifier + "' is not available.");

  return bravojs.requireMemo[id];
}

/** Create a new require function, closing over it's path so that relative
 *  modules work as expected.
 */
bravojs.requireFactory = function bravojs_requireFactory(moduleDir, dependencies)
{
  var deps, i, label;

  function addLabeledDep(moduleIdentifier)
  {
    deps[label] = function bravojs_labeled_dependency()
    {
      return bravojs.requireModule(moduleDir, moduleIdentifier);
    }
  }

  if (dependencies)
  {
    for (i=0; i < dependencies.length; i++)
    {
      if (typeof dependencies[i] !== "object")
        continue;

      for (label in dependencies[i])
      {
        if (dependencies[i].hasOwnProperty(label))
        {
          if (!deps)
            deps = {};
          addLabeledDep(dependencies[i][label]);
        }
      }
    }
  }

  var newRequire = function require(moduleIdentifier)
  {
    if (deps && deps[moduleIdentifier])
      return deps[moduleIdentifier]();
    return bravojs.requireModule(moduleDir, moduleIdentifier);
  }

  newRequire.id = function require_id(moduleIdentifier)
  {
    return bravojs.makeModuleId(moduleDir, moduleIdentifier);
  }

  newRequire.canonicalize = function require_canonicalize(moduleIdentifier)
  {
    var id = bravojs.makeModuleId(moduleDir, moduleIdentifier);

    if (id === '')
    {
      bravojs.e = new Error("Cannot canonically name the resource bearing this main module");
      throw bravojs.e;
    }

    return window.location.protocol + "/" + id + ".js";
  }

  newRequire.memoize = function require_memoize(id, dependencies, moduleFactory)
  {
    bravojs.pendingModuleDeclarations[id] = { moduleFactory: moduleFactory, dependencies: dependencies };
  }

  newRequire.isMemoized = function require_isMemoized(id)
  {
    return (bravojs.pendingModuleDeclarations[id] || bravojs.requireMemo[id]) ? true : false;
  }

  newRequire.paths = bravojs.paths;
  return newRequire;
}

/** Module object constructor
 *
 *  @param      id              The canonical module id
 *  @param      dependencies    The dependency list passed to module.declare
 */
bravojs.Module = function bravojs_Module(id, dependencies)
{
  this.id        = id;
  this.protected = void 0;
  this.dependencies = dependencies;

  var i, label;

  /* Create module.deps array */
  this.deps = {};

  for (i=0; i < dependencies.length; i++)
  {
    if (typeof dependencies[i] === "string")
      continue;

    if (typeof dependencies[i] !== "object")
    {
      bravojs.e = new Error("Invalid " + typeof dependencies[i] + " element in dependency array at position " + i);
      throw bravojs.e;
    }

    /* Labeled dependency object */
    for (label in dependencies[i])
    {
      if (dependencies[i].hasOwnProperty(label))
      {
        this.deps[label] = function bravojs_lambda_module_deps()
        {
          bravojs.requireModule(bravojs.dirname(id), dependencies[i][label]);
        };
      }
    }
  }
}

/** A module.declare suitable for use during DOM SCRIPT-tag insertion.
 *
 *  The general technique described below was invented by Kris Zyp.
 *
 *  In non-old-IE browsers, the script's onload event fires as soon as the
 *  script finishes running, so we just memoize the declaration without
 *  doing anything. After the script is loaded, we do the "real" work
 *  as the onload event also supplies the script's URI, which we use
 *  to generate the canonical module id.
 *
 *  In IE browsers, the event can fire when the tag is being inserted
 *  in the DOM, or sometime thereafter. In the first case, we read a
 *  memo we left behind when we started inserting the tag; in the latter,
 *  we look for interactive scripts.
 *
 *  Note: "IE browsers" describes Internet Explorer versions 6 through 8.
 *        Research has not been done on later versions. Provided the
 *        behaviour either remains the same, or the new behaviour matches
 *        all other browsers, this code will continue to function correctly.
 *
 *  Event                       Action
 *  -------------------------   ------------------------------------------------------------------------------------
 *  Inject Script Tag           onload event populated with URI
 *                              scriptTagMemo populated with URI
 *  IE pulls from cache         cname derived in module.declare from scriptTagMemo, invoke provideModule
 *  IE pulls from http          cname derived in module.declare from script.src, invoke provideModule
 *  Non-old-IE loads script     onload event triggered, most recent incomplete module.declare is completed,
 *                              deriving the cname from the onload event.
 */
bravojs.Module.prototype.declare = function bravojs_Module_declare(dependencies, moduleFactory)
{
  var stm;

  if (typeof dependencies === "function")
  {
    moduleFactory = dependencies;
    dependencies = [];
  }

  stm = bravojs.scriptTagMemo;
  if (stm && stm.id === '')             /* Static HTML module */
  {
    if (bravojs.dependencyDebug)
      bravojs.print("static HTML module depends on:\n" + dependencies.join(",\n"));
    delete bravojs.scriptTagMemo;
    bravojs.provideModule(dependencies, moduleFactory, stm.id, stm.callback);
    return;
  }

  if (stm)
    throw new Error("Bug");

  if (typeof document !== "undefined" && document.addEventListener)     /* non-old-IE, defer work to script's onload event which will happen immediately */
  {
    bravojs.scriptTagMemo = { dependencies: dependencies, moduleFactory: moduleFactory };
    return;
  }

  stm = bravojs.scriptTagMemoIE;
  delete bravojs.scriptTagMemoIE;

  if (stm && stm.id)                    /* old-IE, pulling from cache */
  {
    if (bravojs.dependencyDebug)
      bravojs.print("cached module " + stm.id + " depends on:\n" + depdencies.join(",\n"));
    bravojs.provideModule(dependencies, moduleFactory, stm.id, stm.callback);
    return;
  }

  /* Assume IE fetching from remote */
  var scripts = document.getElementsByTagName("SCRIPT");
  var i;

  for (i = 0; i < scripts.length; i++)
  {
    if (scripts[i].readyState === "interactive")
    {
      if (bravojs.dependencyDebug)
        bravojs.print("remote module " + stm.id + " depends on:\n" + depdencies.join(",\n"));
      bravojs.provideModule(dependencies, moduleFactory, bravojs.URL_toId(scripts[i].src), stm.callback);
      return;
    }
  }

  bravojs.e = new Error("Could not determine module's canonical name from script-tag loader");
  throw bravojs.e;
}

/** A module.provide suitable for a generic web-server back end.  Loads one module at
 *  a time in continuation-passing style, eventually invoking the passed callback.
 *
 *  A more effecient function could be written to take advantage of a web server
 *  which might aggregate and transport more than one module per HTTP request.
 *
 *  @param      dependencies    A dependency array
 *  @param      callback        The callback to invoke once all dependencies have been
 *                              provided to the environment. Optional.
 *  @param      onerror         The callback to invoke in the case there was an error providing
 *                              the module (e.g. 404). May be called more than once.
 */
bravojs.Module.prototype.provide = function bravojs_Module_provide(dependencies, callback, onerror)
{
  var self = arguments.callee;

  if ((typeof dependencies !== "object") || (dependencies.length !== 0 && !dependencies.length))
  {
    bravojs.e = new Error("Invalid dependency array: " + dependencies.toString());
    throw bravojs.e;
  }

  dependencies = bravojs.normalizeDependencyArray(dependencies, this.id ? this.id : undefined);

  if (dependencies.length === 0)
  {
    if (callback)
      callback();
    return;
  }

  module.load(dependencies[0], function bravojs_lambda_provideNextDep() { self(dependencies.slice(1), callback, onerror) }, onerror);
}

/** A module.load suitable for a generic web-server back end. The module is
 *  loaded by injecting a SCRIPT tag into the DOM.
 *
 *  @param      moduleIdentifier        Module to load
 *  @param      callback                Callback to invoke when the module has loaded.
 *  @param      onerror                 The callback to invoke in the case there was an error loading
 *                                      the module (e.g. 404).
 *  @see        bravojs_Module_declare
 */
bravojs.Module.prototype.load = function bravojs_Module_load(moduleIdentifier, callback, onerror)
{
  if (bravojs.global.module.hasOwnProperty("declare"))
    delete bravojs.global.module.declare;

  var script = document.createElement('SCRIPT');
  script.setAttribute("type","text/javascript");
  script.setAttribute("src", require.canonicalize(moduleIdentifier) + "?" + (bravojs.debug === true ? Date.now() : (bravojs.debug ? bravojs.debug : "1")));

  if (document.addEventListener)        /* Non-old-IE; see bravojs_Module_declare */
  {
    script.onload = function bravojs_lambda_script_onload()
    {
      /* stm contains info from recently-run module.declare() */
      var stm = bravojs.scriptTagMemo;
      if (typeof stm === "undefined")
      {
        bravojs.e = new Error("Module '" + moduleIdentifier + "' did not invoke module.declare!");
        throw bravojs.e;
      }

      delete bravojs.scriptTagMemo;
      bravojs.provideModule(stm.dependencies, stm.moduleFactory, require.id(moduleIdentifier), callback);
    }

    script.onerror = function bravojs_lambda_script_onerror(message, url, lineNumber) 
    {
      var id = require.id(moduleIdentifier);
      bravojs.pendingModuleDeclarations[id] = null;     /* Mark null so we don't try to run, but also don't try to reload */
      if (typeof onerror !== "undefined")
        onerror();
      bravojs.e = new Error("Module '" + id + "'" + " not found");
      throw bravojs.e;
    }
  }
  else
  {
    bravojs.scriptTagMemoIE = { moduleIdentifier: moduleIdentifier, callback: callback };

    script.onreadystatechange = function bravojs_lambda_script_onreadystatechange()
    {
      if (this.readyState != "loaded")
        return;

      /* failed load below */
      var id = require.id(moduleIdentifier);

      if (!bravojs.pendingModuleDeclarations[id] && !bravojs.requireMemo[id] && id === bravojs.scriptTagMemoIE.moduleIdentifier)
      {
        bravojs.pendingModuleDeclarations[id] = null;   /* Mark null so we don't try to run, but also don't try to reload */
        if (typeof onerror !== "undefined")
          onerror();
        bravojs.e = new Error("Module '" + id + "'" + " not found");
        throw bravojs.e;
      }
    }
  }

  (document.getElementsByTagName("HEAD")[0] || document.body).appendChild(script);
}

bravojs.Module.prototype.eventually = function(cb) { cb(); };

/** Shim the environment to have CommonJS ES-5 requirements (if needed),
 *  the execute the callback
 */
bravojs.es5_shim_then = function bravojs_es5_shim_then(callback)
{
  if (!Array.prototype.indexOf || !Function.prototype.bind)
  {
    /* Load ES-5 shim into the environment before executing the main module */
    var script = document.createElement('SCRIPT');
    script.setAttribute("type","text/javascript");
    script.setAttribute("src", bravojs.dirname(bravojs.url) + "/global-es5.js" + "?" + (bravojs.debug === true ? Date.now() : (bravojs.debug ? bravojs.debug : "1")));

    if (document.addEventListener)
      script.onload = callback;
    else
    {
      script.onreadystatechange = function()
      {
        if (this.readyState === "loaded")
          callback();
      }
    }

    (document.getElementsByTagName("HEAD")[0] || document.body).appendChild(script);
  }
  else
  {
    callback();
  }
}

/** Reload a module, violating the CommonJS singleton paradigm and
 *  potentially introducing bugs in to the program using this function --
 *  as references to the previous instance of the module may still be
 *  held by the application program.
 */
bravojs.reloadModule = function(id, callback)
{
  delete bravojs.pendingModuleDeclarations[id];
  delete bravojs.requireMemo[id];
  module.provide([id], callback);
}

/** Main module bootstrap */
bravojs.initializeMainModule = function bravojs_initializeMainModule(dependencies, moduleFactory, moduleIdentifier)
{
  if (module.hasOwnProperty("declare"))         /* special extra-module environment bootstrap declare needs to go */
    delete module.declare;

  if (module.constructor.prototype.main)
  {
    bravojs.e = new Error("Main module has already been initialized!");
    throw bravojs.e;
  }

  bravojs.es5_shim_then
  (
    (function()
     {
       bravojs.provideModule(dependencies, moduleFactory, moduleIdentifier,
                             function bravojs_lambda_requireMain()
                             {
                               var main;

                               Object.defineProperty(module.constructor.prototype, "main",
                                                     {
                                                       enumerable:      true,
                                                       configurable:    true,
                                                       get:             function()
                                                       {
                                                         return require(moduleIdentifier);
                                                       }
                                                     });
                               main = require(moduleIdentifier);
                               delete module.constructor.prototype.main;
                               module.constructor.prototype.main = main;
                               if (bravojs.onMainModuleEvaluated)
                                 bravojs.onMainModuleEvaluated();
                             });
     })
  );
}

/** Run a module which is not declared in the HTML document and make it the program module.
 *  @param      dependencies            [optional]      A list of dependencies to sastify before running the module
 *  @param      moduleIdentifier        moduleIdentifier, relative to dirname(window.location.href). This function
 *                                      adjusts the module path such that the program module's directory is the
 *                                      global module directory before the dependencies are resolved.
 *  @param      callback                [optional]      Callback to invoke once the main module has been initialized
 */
bravojs.runExternalMainModule = function bravojs_runExternalMainModule(dependencies, moduleIdentifier, callback)
{
  if (arguments.length === 1 || typeof moduleIdentifier === "function")
  {
    callback = moduleIdentifier;
    moduleIdentifier = dependencies;
    dependencies = [];
  }

  delete module.declare;

  if (moduleIdentifier.charAt(0) === '/')
    bravojs.mainModuleDir = bravojs.dirname(moduleIdentifier);
  else
    bravojs.mainModuleDir = bravojs.dirname(bravojs.URL_toId(window.location.href + ".js"), true) + "/" + bravojs.dirname(moduleIdentifier);

  moduleIdentifier = bravojs.mainModuleDir + '/' + bravojs.basename(moduleIdentifier);

  bravojs.es5_shim_then(
      function() {
        module.provide(dependencies.concat([moduleIdentifier]),
                       function bravojs_runMainModule() {
                         bravojs.initializeMainModule(dependencies, '', moduleIdentifier);
                         if (callback)
                           callback();
                       })
            });
}

bravojs.reset(bravojs.mainModuleDir, bravojs.paths);  /* Use the reset code to initialize state */

/** Set the BravoJS URL, so that BravoJS can load components
 *  relative to its install dir.  The HTML script element that
 *  loads BravoJS must either have the ID BravoJS, or be the
 *  very first script in the document.
 */
(function bravojs_setURL()
{
  var i;
  var scripts;
  var script;

  if (typeof bravojs.url !== "undefined")
    return;

  script = document.getElementById("BravoJS");
  if (!script)
  {
    scripts = document.getElementsByTagName("SCRIPT");
    script = scripts[scripts.length-1];
  }

  bravojs.url = script.src;

  i = bravojs.url.indexOf("?");
  if (i !== -1)
    bravojs.url = bravojs.url.slice(0,i);
  i = bravojs.url.indexOf("#");
  if (i !== -1)
    bravojs.url = bravojs.url.slice(0,i);

  if (bravojs.basename(bravojs.url) !== "bravo.js")
  {
    bravojs.e = new Error("Could not determine BravoJS URL. You can fix this by giving your script tag id='BravoJS'");
    throw bravojs.e;
  }
})();

/** Diagnostic Aids */
if (!bravojs.global.onerror)
{
  bravojs.global.onerror = function bravojs_window_onerror(message, url, line, column, e)
  {
    var s;

    if (bravojs.errorReporter && bravojs.errorReporter.name !== "bravojs_defaultErrorReporter")
    {
      if (typeof e !== "object")
      {
        e =
        {
          name:         "WindowError",
          message:      message,
          lineNumber:   line,
          columnNumber: column,
          fileName:     url
        };
      }

      bravojs.errorReporter(e);
    }
    else if (e && typeof e === "object" && e.stack && typeof print !== "undefined" && print === bravojs.print)
    {
      s = "            ".slice(0,e.name.length);
      console.log("%c" + e.name + ": " + e.message,     "font-weight: bold; color: black;");
      console.log("%c" + s.slice(2) +    "in: " + url,  "color: black;");
      console.log("%c" + s.slice(4) +  "line: " + line, "color: black;");
      if (column)
        console.log("%c" + s.slice(3) +   "col: " + column,"color: black;");
      console.log("%c" + s.slice(5) + "stack: " + e.stack.replace(/\nbravojs_.*/g,"\n").replace(/\n *\n/g,"").split("\n").join("\n  " + s), "color: grey;");
    }
    else
    {
      s =            " * Error: " + message + "\n";
      if (url)  s += "      in: " + url + "\n";
      if (line) s += "    line: " + line + "\n";
      bravojs.print("\n" + s);
    }
  }
}

} catch(e) { bravojs.errorReporter(e); }
;/**
 *  This file extends BravoJS, creating a CommonJS Modules/2.0
 *  environment for WebWorkers and similar environments.
 *
 *  Copyright (c) 2018, Kings Distributed Systems, Ltd.  All Rights Reserved.
 *  Wes Garland, wes@sparc.network
 */

/* global self, bravojs, addEventListener, postMessage */
// @ts-nocheck

self.wrapScriptLoading({ scriptName: 'bravojs-env', ringTransition: true }, (ring1PostMessage, wrapPostMessage) => {
  const ring2PostMessage = self.postMessage;

  bravojs.ww = {}
  bravojs.ww.allDeps = []
  bravojs.ww.provideCallbacks = {}

  addEventListener('message', async (event) => {
    let message = event.data
    let indirectEval = eval // eslint-disable-line
    switch (message.request) {
      case 'moduleGroup': /* Outside environment is sending us a module group */
        module.declare = bravojs.ww.groupedModuleDeclare
        let packages = Object.keys(message.data)

        for (let i = 0; i < packages.length; i++) {
          let fileNames = Object.keys(message.data[packages[i]])
          for (let j = 0; j < fileNames.length; j++) {
            bravojs.ww.moduleId = packages[i] + '/' + fileNames[j]
            try {
              indirectEval(message.data[packages[i]][fileNames[j]], fileNames[j])
            } catch (error) {
              throw error
            }
          }
        }

        delete module.declare

        if (bravojs.ww.provideCallbacks.hasOwnProperty(message.id)) {
          bravojs.ww.provideCallbacks[message.id].callback()
          delete bravojs.ww.provideCallbacks[message.id]
        }
        break
      case 'moduleGroupError': /* Outside environment is sending us a module group error report */
        if (bravojs.ww.provideCallbacks.hasOwnProperty(message.id) && bravojs.ww.provideCallbacks[message.id].onerror) {
          bravojs.ww.provideCallbacks[message.id].onerror()
        } else {
          console.log('moduleGroupError ', message.stack)
        }
        break
      case 'assign':
        try {
          if (!!module.main) {
            throw new Error("Tried to assign sandbox when it was already assigned")
          }

          self.dcpConfig= message.sandboxConfig

          Object.assign(self.work.job.public, message.job.public)

          let workerFunction = indirectEval(`(${message.job.workerFunction})`)

          module.declare(message.job.requireModules, (require, exports, module) => {
            message.job.requirePath.map(p => require.paths.push(p));
            exports.arguments = message.job.arguments
            exports.job = workerFunction
          });

          // Now that the evaluator is assigned, wrap post message for ring 3
          wrapPostMessage();

          ring2PostMessage({
            request:'assigned',
            jobId: message.job.address
          });
        } catch (error) {
          ring2PostMessage({
            request: 'error',
            error: {
              name: error.name,
              message: error.message,
              stack: error.stack.replace(
                /data:application\/javascript.*?:/g,
                'eval:'
              ),
            }
          })
        }
        break
      case 'main':
        try {
          let result = await module.main.job.apply(null,[message.data].concat(module.main.arguments))
          try{ flushLastLog(); } catch(e) {/* do nothing */}
          postMessage({
            request: 'complete',
            result:  result
          });
        } catch (error) {
          try{ flushLastLog(); } catch(e) {/* do nothing */}
          postMessage({
            request: 'workError',
            error: {
              message: error.message,
              name: error.name,
              lineNumber: error.lineNumber,
              columnNumber: error.columnNumber,
              stack: error.stack
            }
          });
        }
        break;
    }
  })

  /** A module.declare suitable for running when processing modules arriving as part
  * of a  module group or other in-memory cache.
  */
  bravojs.ww.groupedModuleDeclare = (dependencies, moduleFactory) => {
    var i
    var moduleBase = ''

    if (bravojs.debug && bravojs.debug.match(/\bmoduleCache\b/)) { console.log('Loaded ' + dependencies + ' from group') }

    if (typeof moduleFactory === 'undefined') {
      moduleFactory = dependencies
      dependencies = []
    }

    bravojs.pendingModuleDeclarations[bravojs.ww.moduleId] = {
      moduleFactory: moduleFactory,
      dependencies: dependencies
    }

    for (i = 0; i < dependencies.length; i++) {
      bravojs.ww.allDeps.push(bravojs.makeModuleId(moduleBase, dependencies[i]))
    }
  }

  /* A module.provide suitable for a web worker, which requests modules via message passing.
*
*  @param  dependencies  A dependency array
*  @param  callback  The callback to invoke once all dependencies have been
*          provided to the environment. Optional.
*  @param    onerror         The callback to invoke in the case there was an error providing
*                            the module (e.g. 404). May be called more than once.
*/
  bravojs.Module.prototype.provide = (dependencies, callback, onerror) => {
    var id = Date.now() + Math.random()

    dependencies = bravojs.normalizeDependencyArray(dependencies)

    bravojs.ww.provideCallbacks[id] = {
      callback: callback,
      onerror: onerror
    }

    ring2PostMessage({
      request: 'dependency',
      data: dependencies,
      id: id
    })
  }

  bravojs.onMainModuleEvaluated = function () {
    ring2PostMessage({
      request: 'mainModuleEvaluated'
    })
  }
});
;/**
 *  @file       worker/evaluator-lib/calculate-capabilities.js
 *              Copyright (c) 2018, Kings Distributed Systems, Ltd.  All Rights Reserved.
 *
 *              This file provides a message handler for handling capabilities requests.
 *
 *  @author     Ryan Rossiter, ryan@kingsds.network
 *  @date       Sept 2020
 */

/* global WebGPUWindow GPU */
// @ts-nocheck

self.wrapScriptLoading(
  { scriptName: 'calculate-capabilities' },
  (ring2PostMessage) => {
    async function getCapabilities() {
      let offscreenCanvas = false;
      let webgpu = false;
      let bigTexture4096 = false;
      let bigTexture8192 = false;
      let bigTexture16384 = false;
      let bigTexture32768 = false;
      const es7 = false;
      const spidermonkey = false;

      let fdlibmFlag = true;
      const inputFdlibm = [
        7.330382858376182753090688493103,
        9.424777960769379347993890405633,
        14.660765716752370835251895186957,
        16.755160819145565653798257699236,
        7.33038285837618,
      ];

      const outputFdlibm = [
        1525.965888988748247356852516531944,
        12391.64780791669181780889630317688,
        2328571.89435723237693309783935546875,
        18909231.8632431328296661376953125,
        1525.965888988744154630694538354874,
      ];

      webgpu =
        typeof GPU !== 'undefined' ||
        (typeof navigator !== 'undefined' &&
          typeof navigator.gpu !== 'undefined');

      if (webgpu) {
        try {
          // if we're in a standalone, we need to initialize a window before requesting adapter
          // These symbols will have to be updated as the webGPU spec keeps updating and as we update our evaluator
          if (typeof WebGPUWindow !== 'undefined') {
            const gpuWindow = new WebGPUWindow({
              width: 640,
              height: 480,
              title: 'DCP-evaluator',
              visible: false,
            });

            const adapter = await GPU.requestAdapter({ gpuWindow });
            await adapter.requestDevice(adapter.extensions);
          } else {
            const adapter = await navigator.gpu.requestAdapter();
            await adapter.requestDevice();
          }
        } catch (err) {
          // if glfw fails or the symbols exist but webgpu hasn't been
          // properly enabled (mozilla)
          webgpu = false;
        }
      }

      offscreenCanvas = !!(
        typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1)
      );

      if (offscreenCanvas) {
        const canvas = new OffscreenCanvas(1, 1);
        try{
          const gl = canvas.getContext('webgl');
          const textureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);

          // Destroy the WebGL context, from https://www.khronos.org/registry/webgl/extensions/WEBGL_lose_context/
          // "This is the recommended mechanism for applications to programmatically halt their use of the WebGL API."
          gl.getExtension('WEBGL_lose_context').loseContext();

          bigTexture4096 = textureSize >= 4096;
          bigTexture8192 = textureSize >= 8192;
          bigTexture16384 = textureSize >= 16384;
          bigTexture32768 = textureSize >= 32768;
        }catch(err){
          //it is possible on some machines, that offscreenCanvas is available but canvas.getContext('webgl' or 'webgl2') results in null
          //Any error in this using an extensions should likely result in specifications for that capability being set to false.
          offscreenCanvas = false;
        }
      }

      try {
        for (let i = 0; i < inputFdlibm.length; i++) {
          if (
            Math.exp(inputFdlibm[i]).toFixed(30) !== outputFdlibm[i].toFixed(30)
          ) {
            fdlibmFlag = false;
            break;
          }
        }
      } catch (err) {
        fdlibmFlag = false;
      }

      return {
        engine: {
          es7,
          spidermonkey,
        },
        environment: {
          webgpu,
          offscreenCanvas,
          fdlibm: fdlibmFlag,
        },
        details: {
          offscreenCanvas: {
            bigTexture4096,
            bigTexture8192,
            bigTexture16384,
            bigTexture32768,
          },
        },
      };
    }

    addEventListener('message', async (event) => {
      try {
        if (event.data.request === 'describe') {
          const capabilities = await getCapabilities();
          ring2PostMessage({
            capabilities,
            request: 'describe',
          });
        }
      } catch (error) {
        ring2PostMessage({
          request: 'error',
          error: {
            name: error.name,
            message: error.message,
            stack: error.stack,
          },
        });
      }
    });
  },
);
;/**
 *  @file       worker/evaluator-lib/bootstrap.js
 *              Copyright (c) 2018, Kings Distributed Systems, Ltd.  All Rights Reserved.
 *
 *              Final evaluator bootstrap code for defining functions to be used in the work function.
 *
 *  @author     Wes Garland, wes@sparc.network
 *  @date       May 2018
 *  @module     WorkerBootstrap
 */

/* globals self */

self.wrapScriptLoading({ scriptName: 'bootstrap', finalScript: true }, (ring2PostMessage) => {
  let lastProgress = 0,
      postMessageSentTime = 0,
      throttledProgress = 0, // how many progress events were throttled since last update
      indeterminateProgress = true, // If there hasn't been a determinate call to progress since last update
      flushedLastConsoleMessage = false, // flag used to determine if flushedLastLog() was called by client
      lastConsoleMessage = null; // cache of the last message received throguh a console event

  addEventListener('message', async (event) => {
    try {
      var indirectEval = eval // eslint-disable-line
      if (event.data.request === 'eval') {
        try {
          let result = await indirectEval(event.data.data, event.data.filename)
          ring2PostMessage({
            request: `evalResult::${event.data.msgId}`,
            data: result
          })
        } catch (error) {
          ring2PostMessage({
            request: 'error',
            error: {
              name: error.name,
              message: error.message,
              stack: error.stack.replace(
                /data:application\/javascript.*?:/g,
                'eval:'
              ),
            }
          })
        }
      } else if (event.data.request === 'resetState') {
        // This event is fired when the web worker is about to be reused with another slice
        lastProgress = 0;
        postMessageSentTime = 0;
        throttledProgress = 0;
        indeterminateProgress = true;
        flushedLastConsoleMessage = false;
        ring2PostMessage({ request: 'resetStateDone' });
      }
    } catch (error) {
      ring2PostMessage({
        request: 'error',
        error: {
          name: error.name,
          message: error.message,
          stack: error.stack,
        }
      })
    }
  })

  const emitNoProgress = (message) => {
    lastProgress = null;
    postMessage({
      request: 'noProgress',
      message
    });
  }

  self.progress = function workerBootstrap$progress(value) {
    // lastProgress is set to null when noProgress is emitted,
    // prevents multiple noProgress events from firing
    if (lastProgress === null) return false;

    let progress, isIndeterminate = false;
    if (value === undefined) {
      progress = lastProgress || 0;
      // if progress was set previously, don't show indeterminate
      if (lastProgress === 0) {
        isIndeterminate = true;
      }
    } else {
      progress = parseFloat(value);

      if (Number.isNaN(progress)) {
        isIndeterminate = true;
      } else {
        if (!(typeof value === 'string' && value.endsWith('%'))) {
          // if the progres value isn't a string ending with % then multiply it by 100
          progress *= 100;
        }
      }
    }

    if (progress < 0 || progress > 100) {
      emitNoProgress(`Progress out of bounds: ${progress.toFixed(1)}%, last: ${lastProgress.toFixed(1)}%`);
      return false;
    } else if (progress < lastProgress) {
      // Nerf reverse progress error, mark as indeterminate // RR Jan 2020
      progress = lastProgress;
      isIndeterminate = true;
    }

    if (!Number.isNaN(progress))
      lastProgress = progress;
    
    if (!self.dcpConfig)
      self.dcpConfig = {};
    if (!self.dcpConfig.worker)
      self.dcpConfig.worker = {};
    if (!self.dcpConfig.worker.sandbox)
      self.dcpConfig.worker.sandbox = {};
    if (!self.dcpConfig.worker.sandbox.progressThrottle)
      self.dcpConfig.worker.sandbox.progressThrottle = 0.1;
    
    indeterminateProgress &= isIndeterminate;
    const throttleTime = self.dcpConfig.worker.sandbox.progressThrottle * 1000;
    if (Date.now() - postMessageSentTime >= throttleTime) {
      postMessageSentTime = Date.now();
      postMessage({
        request: 'progress',
        progress: lastProgress,
        value, // raw value
        indeterminate: indeterminateProgress,
        throttledReports: throttledProgress,
      });

      throttledProgress = 0;
      indeterminateProgress = true;
    } else {
      throttledProgress++;
    }

    flushConsoleMessages(null);
    return true;
  }

  function workerBootstrap$work$emit(eventName, value) {
    if (typeof eventName !== 'string') {
      throw new Error(`Event name passed to work.emit must be a string, not ${eventName}.`);
    }

    postMessage({
      request: 'emitEvent',
      payload: {
        eventName,
        data: value,
      },
    });
  }

  self.work = {
    emit: workerBootstrap$work$emit,
    job: {
      public: {}
    }
  };

  function workerBootstrap$console(level, ...args) {
    let message = args.map(a =>
      (typeof a === 'string'? a : JSON.stringify(a))
    ).join(' ');

    flushConsoleMessages({
        level,
        message,
        fileName: undefined,
        lineNumber: undefined});
  }

  self.console = {
    log:    workerBootstrap$console.bind(null, 'log'),
    debug:  workerBootstrap$console.bind(null, 'debug'),
    info:   workerBootstrap$console.bind(null, 'info'),
    warn:   workerBootstrap$console.bind(null, 'warn'),
    error:  workerBootstrap$console.bind(null, 'error'),
  };

  // Function caches the most recent console message and counts how many identical messages are received
  // Once a different message is received (or when the slice completes) it is sent along with the counter value
  function flushConsoleMessages(data){
    if(lastConsoleMessage != null && data != null && lastConsoleMessage.message == data.message && lastConsoleMessage.level == data.level){
      lastConsoleMessage.same++;
    } else {
      if(lastConsoleMessage != null){
        postMessage({
          request: 'console',
          payload: lastConsoleMessage
        });
        lastConsoleMessage = null;
      }

      if(data != null){
        data.same = 1;
        lastConsoleMessage = data;
      }
    }
  };

  self.flushLastLog = function workerBootstrap$flushLastLog(){
    if(!flushedLastConsoleMessage){
        flushConsoleMessages(null); 
        flushedLastConsoleMessage = true;
    } else{
      throw new Error('client should not be calling flushLastLog');
    }
  }
});
